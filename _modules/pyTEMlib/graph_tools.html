<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyTEMlib.graph_tools &mdash; pyTEMlib 0.2024.01.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=d4dee072"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            pyTEMlib
          </a>
              <div class="version">
                0.2024.01.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">pyTEMlib</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">pyTEMlib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contact.html">Contact us</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../revisions.html">Revisions</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/pyTEMlib.html">pyTEMlib</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyTEMlib</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pyTEMlib.graph_tools</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyTEMlib.graph_tools</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1"># import ase</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># from scipy.spatial import cKDTree, Voronoi, ConvexHull</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span>

<span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">grid_points_in_poly</span><span class="p">,</span> <span class="n">points_in_poly</span>

<span class="c1"># import plotly.graph_objects as go</span>
<span class="c1"># import plotly.express as px</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">patches</span>

<span class="kn">import</span> <span class="nn">pyTEMlib.crystal_tools</span>
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span><span class="p">,</span> <span class="n">trange</span>

<span class="kn">from</span> <span class="nn">.graph_viz</span> <span class="kn">import</span> <span class="o">*</span>


<span class="c1">###########################################################################</span>
<span class="c1"># utility functions</span>
<span class="c1">###########################################################################</span>

<div class="viewcode-block" id="interstitial_sphere_center"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.interstitial_sphere_center.html#pyTEMlib.graph_tools.interstitial_sphere_center">[docs]</a><span class="k">def</span> <span class="nf">interstitial_sphere_center</span><span class="p">(</span><span class="n">vertex_pos</span><span class="p">,</span> <span class="n">atom_radii</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function finds center and radius of the largest interstitial sphere of a simplex.</span>
<span class="sd">        Which is the center of the cirumsphere if all atoms have the same radius,</span>
<span class="sd">        but differs for differently sized atoms.</span>
<span class="sd">        In the last case, the circumsphere center is used as starting point for refinement.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------</span>
<span class="sd">        vertex_pos : numpy array</span>
<span class="sd">            The position of vertices of a tetrahedron</span>
<span class="sd">        atom_radii : float</span>
<span class="sd">            bond radii of atoms</span>
<span class="sd">        optimize: boolean</span>
<span class="sd">            whether atom bond lengths are optimized or not</span>
<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        new_center : numpy array</span>
<span class="sd">            The center of the largest interstitial sphere</span>
<span class="sd">        radius : float</span>
<span class="sd">            The radius of the largest interstitial sphere</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">center</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">circum_center</span><span class="p">(</span><span class="n">vertex_pos</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">distance_deviation</span><span class="p">(</span><span class="n">sphere_center</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vertex_pos</span> <span class="o">-</span> <span class="n">sphere_center</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">atom_radii</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">atom_radii</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">optimize</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="o">-</span><span class="n">atom_radii</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">center_new</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">distance_deviation</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">center_new</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vertex_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">center_new</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">atom_radii</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="circum_center"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.circum_center.html#pyTEMlib.graph_tools.circum_center">[docs]</a><span class="k">def</span> <span class="nf">circum_center</span><span class="p">(</span><span class="n">vertex_pos</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function finds the center and the radius of the circumsphere of every simplex.</span>
<span class="sd">    Reference:</span>
<span class="sd">    Fiedler, Miroslav. Matrices and graphs in geometry. No. 139. Cambridge University Press, 2011.</span>
<span class="sd">    (p.29 bottom: example 2.1.11)</span>
<span class="sd">    Code started from https://github.com/spatala/gbpy</span>
<span class="sd">    with help of https://codereview.stackexchange.com/questions/77593/calculating-the-volume-of-a-tetrahedron</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------------</span>
<span class="sd">    vertex_pos : numpy array</span>
<span class="sd">        The position of vertices of a tetrahedron</span>
<span class="sd">    tol : float</span>
<span class="sd">        Tolerance defined  to identify co-planar tetrahedrons</span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    circum_center : numpy array</span>
<span class="sd">        The center of the circumsphere</span>
<span class="sd">    circum_radius : float</span>
<span class="sd">        The radius of the circumsphere</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Make Cayley-Menger Matrix</span>
    <span class="n">number_vertices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex_pos</span><span class="p">)</span>
    <span class="n">matrix_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">number_vertices</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*-</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vertex_pos</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;sqeuclidean&#39;</span><span class="p">)</span>
    <span class="n">matrix_c</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
    <span class="n">det_matrix_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">matrix_c</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">det_matrix_c</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertex_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">matrix_c</span><span class="p">)</span>

    <span class="n">center</span> <span class="o">=</span> <span class="n">vertex_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_vertices</span><span class="p">):</span>
        <span class="n">center</span> <span class="o">+=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">vertex_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">center</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span>

    <span class="n">circum_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center</span><span class="p">),</span> <span class="n">circum_radius</span></div>


<div class="viewcode-block" id="voronoi_volumes"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.voronoi_volumes.html#pyTEMlib.graph_tools.voronoi_volumes">[docs]</a><span class="k">def</span> <span class="nf">voronoi_volumes</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Volumes of voronoi  cells from</span>
<span class="sd">    https://stackoverflow.com/questions/19634993/volume-of-voronoi-cell-python</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">Voronoi</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">npoints</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reg_num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">point_region</span><span class="p">):</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="n">reg_num</span><span class="p">]</span>
        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>  <span class="c1"># some regions can be opened</span>
            <span class="n">vol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">hull</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">ConvexHull</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
                <span class="n">vol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hull</span><span class="o">.</span><span class="n">volume</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">vol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># atoms.info.update({&#39;volumes&#39;: vol})</span>
    <span class="k">return</span> <span class="n">vol</span></div>


<div class="viewcode-block" id="get_bond_radii"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.get_bond_radii.html#pyTEMlib.graph_tools.get_bond_radii">[docs]</a><span class="k">def</span> <span class="nf">get_bond_radii</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">bond_type</span><span class="o">=</span><span class="s1">&#39;bond&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; get all bond radii from Kirkland </span>
<span class="sd">    Parameter:</span>
<span class="sd">    ----------</span>
<span class="sd">    atoms ase.Atoms object</span>
<span class="sd">        structure information in ase format</span>
<span class="sd">    type: str</span>
<span class="sd">        type of bond &#39;covalent&#39; or &#39;metallic&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">r_a</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">symbol</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
            <span class="n">r_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bond_type</span> <span class="o">==</span> <span class="s1">&#39;covalent&#39;</span><span class="p">:</span>
                <span class="n">r_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyTEMlib</span><span class="o">.</span><span class="n">crystal_tools</span><span class="o">.</span><span class="n">electronFF</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">symbol</span><span class="p">][</span><span class="s1">&#39;bond_length&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyTEMlib</span><span class="o">.</span><span class="n">crystal_tools</span><span class="o">.</span><span class="n">electronFF</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">symbol</span><span class="p">][</span><span class="s1">&#39;bond_length&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bond_radii&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_a</span>
    <span class="k">return</span> <span class="n">r_a</span></div>


<div class="viewcode-block" id="set_bond_radii"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.set_bond_radii.html#pyTEMlib.graph_tools.set_bond_radii">[docs]</a><span class="k">def</span> <span class="nf">set_bond_radii</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">bond_type</span><span class="o">=</span><span class="s1">&#39;bond&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; set certain or all bond-radii taken from Kirkland </span>
<span class="sd">    </span>
<span class="sd">    Bond_radii are also stored in atoms.info</span>
<span class="sd">    </span>
<span class="sd">    Parameter:</span>
<span class="sd">    ----------</span>
<span class="sd">    atoms ase.Atoms object</span>
<span class="sd">        structure information in ase format</span>
<span class="sd">    type: str</span>
<span class="sd">        type of bond &#39;covalent&#39; or &#39;metallic&#39;</span>
<span class="sd">    Return:</span>
<span class="sd">    -------</span>
<span class="sd">    r_a: list</span>
<span class="sd">        list of atomic bond-radii </span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="s1">&#39;bond_radii&#39;</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">r_a</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bond_radii&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span>
        
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bond_type</span> <span class="o">==</span> <span class="s1">&#39;covalent&#39;</span><span class="p">:</span>
            <span class="n">r_a</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pyTEMlib</span><span class="o">.</span><span class="n">crystal_tools</span><span class="o">.</span><span class="n">electronFF</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">symbol</span><span class="p">][</span><span class="s1">&#39;bond_length&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r_a</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pyTEMlib</span><span class="o">.</span><span class="n">crystal_tools</span><span class="o">.</span><span class="n">electronFF</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">symbol</span><span class="p">][</span><span class="s1">&#39;bond_length&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bond_radii&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_a</span>
    <span class="k">return</span> <span class="n">r_a</span></div>


<div class="viewcode-block" id="get_voronoi"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.get_voronoi.html#pyTEMlib.graph_tools.get_voronoi">[docs]</a><span class="k">def</span> <span class="nf">get_voronoi</span><span class="p">(</span><span class="n">tetrahedra</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">bond_radii</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find Voronoi vertices and keep track of associated tetrahedrons and interstitial radii</span>

<span class="sd">    Used in find_polyhedra function</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tetrahedra: scipy.spatial.Delaunay object</span>
<span class="sd">        Delaunay tesselation</span>
<span class="sd">    atoms: ase.Atoms object</span>
<span class="sd">        the structural information</span>
<span class="sd">    optimize: boolean</span>
<span class="sd">        whether to use different atom radii or not</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    voronoi_vertices: list</span>
<span class="sd">        list of positions of voronoi vertices</span>
<span class="sd">    voronoi_tetrahedra:</span>
<span class="sd">        list of indices of associated vertices of tetrahedra</span>
<span class="sd">    r_vv: list of float</span>
<span class="sd">        list of all interstitial sizes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">extent</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">lengths</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">bond_radii</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bond_radii</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond_radii</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s1">&#39;bond_radii&#39;</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">bond_radii</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bond_radii&#39;</span><span class="p">]</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bond_radii</span> <span class="o">=</span> <span class="n">get_bond_radii</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        
    <span class="n">voronoi_vertices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">voronoi_tetrahedrons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">r_vv</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">r_aa</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Find interstitials (finding centers for different elements takes a bit)&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">vertices</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">tetrahedra</span><span class="o">.</span><span class="n">simplices</span><span class="p">):</span>
        <span class="n">r_a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
            <span class="n">r_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bond_radii</span><span class="p">[</span><span class="n">vert</span><span class="p">])</span>
        <span class="n">voronoi</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">interstitial_sphere_center</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">vertices</span><span class="p">],</span> <span class="n">r_a</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">optimize</span><span class="p">)</span>

        <span class="n">r_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">r_a</span><span class="p">)</span>  <span class="c1"># np.min(r_a)</span>
        <span class="n">r_aa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_a</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">voronoi</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">extent</span> <span class="o">-</span> <span class="n">voronoi</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="n">radius</span> <span class="o">&gt;</span> <span class="mf">0.01</span><span class="p">:</span>
            <span class="n">voronoi_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">voronoi</span><span class="p">)</span>
            <span class="n">voronoi_tetrahedrons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
            <span class="n">r_vv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">voronoi_vertices</span><span class="p">,</span> <span class="n">voronoi_tetrahedrons</span><span class="p">,</span> <span class="n">r_vv</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">r_aa</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_overlapping_spheres"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.find_overlapping_spheres.html#pyTEMlib.graph_tools.find_overlapping_spheres">[docs]</a><span class="k">def</span> <span class="nf">find_overlapping_spheres</span><span class="p">(</span><span class="n">voronoi_vertices</span><span class="p">,</span> <span class="n">r_vv</span><span class="p">,</span> <span class="n">r_a</span><span class="p">,</span> <span class="n">cheat</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find overlapping spheres&quot;&quot;&quot;</span>

    <span class="n">vertex_tree</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">voronoi_vertices</span><span class="p">)</span>

    <span class="n">pairs</span> <span class="o">=</span> <span class="n">vertex_tree</span><span class="o">.</span><span class="n">query_pairs</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">r_a</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">overlapping_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">voronoi_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">voronoi_vertices</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">r_vv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">r_vv</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="n">cheat</span><span class="p">:</span>
            <span class="n">overlapping_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">overlapping_pairs</span><span class="p">))</span></div>


<div class="viewcode-block" id="find_interstitial_clusters"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.find_interstitial_clusters.html#pyTEMlib.graph_tools.find_interstitial_clusters">[docs]</a><span class="k">def</span> <span class="nf">find_interstitial_clusters</span><span class="p">(</span><span class="n">overlapping_pairs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make clusters</span>
<span class="sd">    Breadth first search to go through the list of overlapping spheres or circles to determine clusters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">visited_all</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">initial</span> <span class="ow">in</span> <span class="n">overlapping_pairs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">initial</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_all</span><span class="p">:</span>
            <span class="c1"># breadth first search</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the atoms we visited</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_all</span><span class="p">:</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">visited_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="c1"># neighbors = overlapping_pairs[overlapping_pairs[:,0]==node,1]</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">overlapping_pairs</span><span class="p">[</span><span class="n">overlapping_pairs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                          <span class="n">overlapping_pairs</span><span class="p">[</span><span class="n">overlapping_pairs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">neighbour</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span>
            <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">visited_all</span></div>


<div class="viewcode-block" id="make_polygons"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.make_polygons.html#pyTEMlib.graph_tools.make_polygons">[docs]</a><span class="k">def</span> <span class="nf">make_polygons</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">voronoi_vertices</span><span class="p">,</span> <span class="n">voronoi_tetrahedrons</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">visited_all</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; make polygons from convex hulls of vertices around interstitial positions&quot;&quot;&quot;</span>
    <span class="n">polyhedra</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">)):</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">cc</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">voronoi_tetrahedrons</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>

        <span class="n">hull</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">ConvexHull</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cc</span><span class="p">)),</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>
            <span class="n">faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cc</span><span class="p">))][</span><span class="n">s</span><span class="p">])</span>
            <span class="n">triangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="n">polyhedra</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vertices&#39;</span><span class="p">:</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cc</span><span class="p">))],</span> <span class="s1">&#39;indices&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cc</span><span class="p">)),</span>
                            <span class="s1">&#39;faces&#39;</span><span class="p">:</span> <span class="n">faces</span><span class="p">,</span> <span class="s1">&#39;triangles&#39;</span><span class="p">:</span> <span class="n">triangles</span><span class="p">,</span>
                            <span class="s1">&#39;length&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cc</span><span class="p">))),</span>
                            <span class="s1">&#39;combined_vertices&#39;</span><span class="p">:</span> <span class="n">cluster</span><span class="p">,</span>
                            <span class="s1">&#39;interstitial_index&#39;</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span>
                            <span class="s1">&#39;interstitial_site&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">voronoi_tetrahedrons</span><span class="p">)[</span><span class="n">cluster</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                            <span class="s1">&#39;atomic_numbers&#39;</span><span class="p">:</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">()[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cc</span><span class="p">))]}</span>   <span class="c1"># , &#39;volume&#39;: hull.volume}</span>
        <span class="c1"># &#39;coplanar&#39;: hull.coplanar}</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Define conventional interstitial polyhedra&#39;</span><span class="p">)</span>
    <span class="n">running_number</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">trange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">voronoi_vertices</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_all</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">voronoi_tetrahedrons</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">hull</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">ConvexHull</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">vertices</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">triangles</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>
                <span class="n">faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">vertices</span><span class="p">][</span><span class="n">s</span><span class="p">])</span>
                <span class="n">triangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

            <span class="n">polyhedra</span><span class="p">[</span><span class="n">running_number</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vertices&#39;</span><span class="p">:</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">vertices</span><span class="p">],</span> <span class="s1">&#39;indices&#39;</span><span class="p">:</span> <span class="n">vertices</span><span class="p">,</span>
                                         <span class="s1">&#39;faces&#39;</span><span class="p">:</span> <span class="n">faces</span><span class="p">,</span> <span class="s1">&#39;triangles&#39;</span><span class="p">:</span> <span class="n">triangles</span><span class="p">,</span>
                                         <span class="s1">&#39;length&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span>
                                         <span class="s1">&#39;combined_vertices&#39;</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span>
                                         <span class="s1">&#39;interstitial_index&#39;</span><span class="p">:</span> <span class="n">running_number</span><span class="p">,</span>
                                         <span class="s1">&#39;interstitial_site&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">voronoi_tetrahedrons</span><span class="p">)[</span><span class="n">index</span><span class="p">],</span>
                                         <span class="s1">&#39;atomic_numbers&#39;</span><span class="p">:</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">()[</span><span class="n">vertices</span><span class="p">]}</span>
            <span class="c1"># &#39;volume&#39;: hull.volume}</span>

            <span class="n">running_number</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">polyhedra</span></div>


<div class="viewcode-block" id="make_polyhedrons"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.make_polyhedrons.html#pyTEMlib.graph_tools.make_polyhedrons">[docs]</a><span class="k">def</span> <span class="nf">make_polyhedrons</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">voronoi_vertices</span><span class="p">,</span> <span class="n">voronoi_tetrahedrons</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">visited_all</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;collect output data  and make dictionary&quot;&quot;&quot;</span>

    <span class="n">polyhedra</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="kn">import</span> <span class="nn">scipy.sparse</span>
    <span class="n">connectivity_matrix</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">dok_matrix</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Define clustered interstitial polyhedra&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">)):</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">cc</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">voronoi_tetrahedrons</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cc</span><span class="p">))</span>

        <span class="n">hull</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">ConvexHull</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">cc</span><span class="p">])</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>
            <span class="n">faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">cc</span><span class="p">][</span><span class="n">s</span><span class="p">])</span>
            <span class="n">triangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
                <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cc</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">cc</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]]:</span>
                    <span class="n">connectivity_matrix</span><span class="p">[</span><span class="n">cc</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]],</span> <span class="n">cc</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">connectivity_matrix</span><span class="p">[</span><span class="n">cc</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]],</span> <span class="n">cc</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">polyhedra</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vertices&#39;</span><span class="p">:</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cc</span><span class="p">))],</span> <span class="s1">&#39;indices&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cc</span><span class="p">)),</span>
                            <span class="s1">&#39;faces&#39;</span><span class="p">:</span> <span class="n">faces</span><span class="p">,</span> <span class="s1">&#39;triangles&#39;</span><span class="p">:</span> <span class="n">triangles</span><span class="p">,</span>
                            <span class="s1">&#39;length&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cc</span><span class="p">))),</span>
                            <span class="s1">&#39;combined_vertices&#39;</span><span class="p">:</span> <span class="n">cluster</span><span class="p">,</span>
                            <span class="s1">&#39;interstitial_index&#39;</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span>
                            <span class="s1">&#39;interstitial_site&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">voronoi_tetrahedrons</span><span class="p">)[</span><span class="n">cluster</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                            <span class="s1">&#39;atomic_numbers&#39;</span><span class="p">:</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">()[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cc</span><span class="p">))],</span>
                            <span class="s1">&#39;volume&#39;</span><span class="p">:</span> <span class="n">hull</span><span class="o">.</span><span class="n">volume</span><span class="p">}</span>
        <span class="c1"># &#39;coplanar&#39;: hull.coplanar}</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Define conventional interstitial polyhedra&#39;</span><span class="p">)</span>
    <span class="n">running_number</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">voronoi_vertices</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_all</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">voronoi_tetrahedrons</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">hull</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">ConvexHull</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">vertices</span><span class="p">])</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">triangles</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>
                <span class="n">faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">vertices</span><span class="p">][</span><span class="n">s</span><span class="p">])</span>
                <span class="n">triangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cc</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">cc</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]]:</span>
                        <span class="n">connectivity_matrix</span><span class="p">[</span><span class="n">cc</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]],</span> <span class="n">cc</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">connectivity_matrix</span><span class="p">[</span><span class="n">cc</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]],</span> <span class="n">cc</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">polyhedra</span><span class="p">[</span><span class="n">running_number</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vertices&#39;</span><span class="p">:</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">vertices</span><span class="p">],</span> <span class="s1">&#39;indices&#39;</span><span class="p">:</span> <span class="n">vertices</span><span class="p">,</span>
                                         <span class="s1">&#39;faces&#39;</span><span class="p">:</span> <span class="n">faces</span><span class="p">,</span> <span class="s1">&#39;triangles&#39;</span><span class="p">:</span> <span class="n">triangles</span><span class="p">,</span>
                                         <span class="s1">&#39;length&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span>
                                         <span class="s1">&#39;combined_vertices&#39;</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span>
                                         <span class="s1">&#39;interstitial_index&#39;</span><span class="p">:</span> <span class="n">running_number</span><span class="p">,</span>
                                         <span class="s1">&#39;interstitial_site&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">voronoi_tetrahedrons</span><span class="p">)[</span><span class="n">index</span><span class="p">],</span>
                                         <span class="s1">&#39;atomic_numbers&#39;</span><span class="p">:</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">()[</span><span class="n">vertices</span><span class="p">],</span>
                                         <span class="s1">&#39;volume&#39;</span><span class="p">:</span> <span class="n">hull</span><span class="o">.</span><span class="n">volume</span><span class="p">}</span>

            <span class="n">running_number</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;graph&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;connectivity_matrix&#39;</span><span class="p">:</span> <span class="n">connectivity_matrix</span><span class="p">}})</span>
    <span class="k">return</span> <span class="n">polyhedra</span></div>


<span class="c1">##################################################################</span>
<span class="c1"># polyhedra functions</span>
<span class="c1">##################################################################</span>

<div class="viewcode-block" id="get_non_periodic_supercell"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.get_non_periodic_supercell.html#pyTEMlib.graph_tools.get_non_periodic_supercell">[docs]</a><span class="k">def</span> <span class="nf">get_non_periodic_supercell</span><span class="p">(</span><span class="n">super_cell</span><span class="p">):</span>
    <span class="n">super_cell</span><span class="o">.</span><span class="n">wrap</span><span class="p">()</span>
    <span class="n">atoms</span> <span class="o">=</span> <span class="n">super_cell</span><span class="o">*</span><span class="mi">3</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">-=</span> <span class="n">super_cell</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">lengths</span><span class="p">()</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">super_cell</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mf">.0</span>
    <span class="k">del</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:</span> <span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">&lt;-</span><span class="mi">5</span><span class="p">])</span>
    <span class="k">del</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:</span> <span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">super_cell</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">5</span><span class="p">])</span>
    <span class="k">del</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:</span> <span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">&lt;-</span><span class="mi">5</span><span class="p">])</span>
    <span class="k">del</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:</span> <span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">super_cell</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">5</span><span class="p">])</span>
    <span class="k">del</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:</span> <span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">&lt;-</span><span class="mi">5</span><span class="p">])</span>
    <span class="k">del</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:</span> <span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="n">super_cell</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">5</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">atoms</span></div>

<div class="viewcode-block" id="get_connectivity_matrix"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.get_connectivity_matrix.html#pyTEMlib.graph_tools.get_connectivity_matrix">[docs]</a><span class="k">def</span> <span class="nf">get_connectivity_matrix</span><span class="p">(</span><span class="n">crystal</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">polyhedra</span><span class="p">):</span>
    <span class="n">crystal_tree</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">crystal</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>
    
    
    <span class="n">connectivity_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">polyhedron</span> <span class="ow">in</span> <span class="n">polyhedra</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;vertices&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">crystal</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">lengths</span><span class="p">()</span>
        <span class="n">atom_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;indices&#39;</span><span class="p">])</span>
        <span class="n">dd</span><span class="p">,</span> <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;atom_indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">crystal_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">vertices</span> <span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">to_bond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dd</span><span class="o">&lt;</span><span class="mf">0.001</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
       
        <span class="k">for</span> <span class="n">triangle</span> <span class="ow">in</span> <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;triangles&#39;</span><span class="p">]:</span>
            <span class="n">triangle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">triangle</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">permut</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]]:</span>
                <span class="n">vertex</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">triangle</span><span class="p">[</span><span class="n">permut</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">triangle</span><span class="p">[</span><span class="n">permut</span><span class="p">])]</span>
                <span class="k">if</span> <span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_bond</span> <span class="ow">or</span> <span class="n">vertex</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_bond</span><span class="p">:</span>
                    <span class="n">connectivity_matrix</span><span class="p">[</span><span class="n">atom_ind</span><span class="p">[</span><span class="n">vertex</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">atom_ind</span><span class="p">[</span><span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span> 
                    <span class="n">connectivity_matrix</span><span class="p">[</span><span class="n">atom_ind</span><span class="p">[</span><span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">atom_ind</span><span class="p">[</span><span class="n">vertex</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span> 
    <span class="k">return</span> <span class="n">connectivity_matrix</span></div>
    


<div class="viewcode-block" id="get_bonds"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.get_bonds.html#pyTEMlib.graph_tools.get_bonds">[docs]</a><span class="k">def</span> <span class="nf">get_bonds</span><span class="p">(</span><span class="n">crystal</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cheat</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get polyhedra, and bonds from  and edges and lengths of edges for each polyhedron and store it in info dictionary of new ase.Atoms object</span>
<span class="sd">    </span>
<span class="sd">    Parameter:</span>
<span class="sd">    ----------</span>
<span class="sd">    crystal: ase.atoms_object</span>
<span class="sd">        information on all polyhedra</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">crystal</span><span class="o">.</span><span class="n">positions</span> <span class="o">+=</span> <span class="n">shift</span> <span class="o">*</span> <span class="n">crystal</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">crystal</span><span class="o">.</span><span class="n">wrap</span><span class="p">()</span>
   
    <span class="n">atoms</span> <span class="o">=</span> <span class="n">get_non_periodic_supercell</span><span class="p">(</span><span class="n">crystal</span><span class="p">)</span>
    <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="o">.</span><span class="n">numbers</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>

    
    <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">+=</span> <span class="n">crystal</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">lengths</span><span class="p">()</span>
    <span class="n">polyhedra</span> <span class="o">=</span> <span class="n">find_polyhedra</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">cheat</span><span class="o">=</span><span class="n">cheat</span><span class="p">)</span>

    <span class="n">connectivity_matrix</span> <span class="o">=</span> <span class="n">get_connectivity_matrix</span><span class="p">(</span><span class="n">crystal</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">polyhedra</span><span class="p">)</span> 
    <span class="n">coord</span> <span class="o">=</span> <span class="n">connectivity_matrix</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">del</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">coord</span><span class="o">==</span><span class="mi">0</span><span class="p">)])</span>
    <span class="n">new_polyhedra</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">octahedra</span> <span class="o">=</span><span class="p">[]</span>
    <span class="n">tetrahedra</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">other</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">super_cell_atoms</span> <span class="o">=</span><span class="p">[]</span>
    
    <span class="n">atoms_tree</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="o">-</span><span class="n">crystal</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">lengths</span><span class="p">())</span>
    <span class="n">crystal_tree</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">crystal</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>
    <span class="n">connectivity_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">polyhedron</span> <span class="ow">in</span> <span class="n">polyhedra</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;vertices&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="n">crystal</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">lengths</span><span class="p">()</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;vertices&#39;</span><span class="p">]</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;vertices&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="n">dd</span><span class="p">,</span> <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">vertices</span> <span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">atom_ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;indices&#39;</span><span class="p">]))</span>
        <span class="n">dd</span><span class="p">,</span> <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;atom_indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">crystal_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">vertices</span> <span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">to_bond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dd</span><span class="o">&lt;</span><span class="mf">0.001</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">super_cell_atoms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">atom_ind</span><span class="p">[</span><span class="n">to_bond</span><span class="p">]))</span>
        
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">triangle</span> <span class="ow">in</span> <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;triangles&#39;</span><span class="p">]:</span>
            <span class="n">triangle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">triangle</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">permut</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]]:</span>
                <span class="n">vertex</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">triangle</span><span class="p">[</span><span class="n">permut</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">triangle</span><span class="p">[</span><span class="n">permut</span><span class="p">])]</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">-</span><span class="n">vertices</span><span class="p">[</span><span class="n">vertex</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">if</span> <span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_bond</span> <span class="ow">or</span> <span class="n">vertex</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_bond</span><span class="p">:</span>
                    <span class="n">connectivity_matrix</span><span class="p">[</span><span class="n">atom_ind</span><span class="p">[</span><span class="n">vertex</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">atom_ind</span><span class="p">[</span><span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">length</span> 
                    <span class="n">connectivity_matrix</span><span class="p">[</span><span class="n">atom_ind</span><span class="p">[</span><span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">atom_ind</span><span class="p">[</span><span class="n">vertex</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">length</span> 
                    <span class="k">if</span> <span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_bond</span><span class="p">:</span>
                        <span class="n">atoms</span><span class="p">[</span><span class="n">atom_ind</span><span class="p">[</span><span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span><span class="o">.</span><span class="n">symbol</span> <span class="o">=</span> <span class="s1">&#39;Be&#39;</span>
                    <span class="k">if</span> <span class="n">vertex</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_bond</span><span class="p">:</span> 
                        <span class="n">atoms</span><span class="p">[</span><span class="n">atom_ind</span><span class="p">[</span><span class="n">vertex</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span><span class="o">.</span><span class="n">symbol</span> <span class="o">=</span> <span class="s1">&#39;Be&#39;</span>
                <span class="k">if</span> <span class="n">vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
                    <span class="n">lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">-</span><span class="n">vertices</span><span class="p">[</span><span class="n">vertex</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="p">))</span>
        <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span>
        <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;edge_lengths&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lengths</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">center</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">0.000001</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">center</span> <span class="o">&lt;</span> <span class="n">crystal</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">lengths</span><span class="p">()</span><span class="o">-</span><span class="mf">0.01</span><span class="p">):</span>
                <span class="n">new_polyhedra</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span><span class="o">=</span><span class="n">polyhedron</span>
                <span class="k">if</span> <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">tetrahedra</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span> 
                <span class="k">elif</span> <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                    <span class="n">octahedra</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">])</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">-=</span> <span class="n">crystal</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">lengths</span><span class="p">()</span>
    <span class="n">coord</span> <span class="o">=</span> <span class="n">connectivity_matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">coord</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">coord</span><span class="o">&gt;</span><span class="mf">.1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">coord</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">super_cell_atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">super_cell_atoms</span><span class="p">))</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;polyhedra&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;polyhedra&#39;</span><span class="p">:</span> <span class="n">new_polyhedra</span><span class="p">,</span> 
                                    <span class="s1">&#39;tetrahedra&#39;</span><span class="p">:</span> <span class="n">tetrahedra</span><span class="p">,</span>
                                    <span class="s1">&#39;octahedra&#39;</span><span class="p">:</span> <span class="n">octahedra</span><span class="p">,</span>
                                    <span class="s1">&#39;other&#39;</span> <span class="p">:</span> <span class="n">other</span><span class="p">}})</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;bonds&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;connectivity_matrix&#39;</span><span class="p">:</span> <span class="n">connectivity_matrix</span><span class="p">,</span> 
                                 <span class="s1">&#39;super_cell_atoms&#39;</span><span class="p">:</span> <span class="n">super_cell_atoms</span><span class="p">,</span>
                                 <span class="s1">&#39;super_cell_dimensions&#39;</span><span class="p">:</span> <span class="n">crystal</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                                 <span class="s1">&#39;coordination&#39;</span><span class="p">:</span> <span class="n">coord</span><span class="p">}})</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;supercell&#39;</span><span class="p">:</span> <span class="n">crystal</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">atoms</span>    </div>

<div class="viewcode-block" id="plot_atoms"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.plot_atoms.html#pyTEMlib.graph_tools.plot_atoms">[docs]</a><span class="k">def</span> <span class="nf">plot_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">:</span> <span class="n">ase</span><span class="o">.</span><span class="n">Atoms</span><span class="p">,</span> <span class="n">polyhedra_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot_bonds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">template</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atom_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">35</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot structure in a ase.Atoms object with plotly</span>
<span class="sd">    </span>
<span class="sd">    If the info dictionary of the atoms object contains bond or polyedra information, these can be set tobe plotted</span>
<span class="sd">    </span>
<span class="sd">    Partameter:</span>
<span class="sd">    -----------</span>
<span class="sd">    atoms: ase.Atoms object</span>
<span class="sd">        structure of supercell</span>
<span class="sd">    polyhedra_indices: list of integers</span>
<span class="sd">        indices of polyhedra to be plotted</span>
<span class="sd">    plot_bonds: boolean</span>
<span class="sd">        whether to plot bonds or not</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    fig: plotly figure object</span>
<span class="sd">        handle to figure needed to modify appearance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span>
    <span class="k">if</span> <span class="s1">&#39;bonds&#39;</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;atom_energy&#39;</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]:</span>
            <span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">][</span><span class="s1">&#39;atom_energy&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">12</span> <span class="o">*</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">][</span><span class="s1">&#39;ideal_bond_energy&#39;</span><span class="p">])</span> <span class="o">*</span><span class="mi">1000</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">][</span><span class="s1">&#39;super_cell_atoms&#39;</span><span class="p">]:</span>
                    <span class="n">energies</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;coordination&#39;</span><span class="p">:</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">][</span><span class="s1">&#39;coordination&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;layer&#39;</span><span class="p">:</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;energy&#39;</span><span class="p">:</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">energies</span>
        <span class="n">colors</span><span class="p">[</span><span class="n">colors</span><span class="o">&gt;</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span> <span class="n">energies</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">colors</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">atom_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">atom_size</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">()</span><span class="o">*</span><span class="mi">4</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom_size</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">atom_size</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">()</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="n">atom_size</span>
        <span class="n">atom_size</span><span class="p">[</span><span class="n">atom_size</span><span class="o">&gt;</span><span class="n">max_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_size</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">atom_size</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom_size</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom_size</span><span class="p">)</span> <span class="o">!=</span>  <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
        <span class="n">atom_size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;wrong length of atom_size parameter&#39;</span><span class="p">)</span>
    <span class="n">plot_polyhedra</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">polyhedra_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;polyhedra&#39;</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>   
            <span class="k">if</span> <span class="n">polyhedra_indices</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">plot_polyhedron</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;polyhedra&#39;</span><span class="p">][</span><span class="s1">&#39;polyhedra&#39;</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;polyhedra&#39;</span><span class="p">][</span><span class="s1">&#39;polyhedra&#39;</span><span class="p">])))</span>
                <span class="n">plot_polyhedra</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polyhedra_indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">plot_polyhedron</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;polyhedra&#39;</span><span class="p">][</span><span class="s1">&#39;polyhedra&#39;</span><span class="p">],</span> <span class="n">polyhedra_indices</span><span class="p">)</span>
                <span class="n">plot_polyhedra</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">text</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="s1">&#39;bonds&#39;</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">][</span><span class="s1">&#39;coordination&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">index</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">][</span><span class="s1">&#39;super_cell_atoms&#39;</span><span class="p">]:</span>

                <span class="n">text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Atom </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s1">: coordination=</span><span class="si">{</span><span class="n">coord</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span> <span class="o">+</span>
                            <span class="sa">f</span><span class="s1">&#39;x:</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> </span><span class="se">\n</span><span class="s1"> y:</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> </span><span class="se">\n</span><span class="s1"> z:</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;atom_energy&#39;</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]:</span>
                    <span class="n">text</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> energy: </span><span class="si">{</span><span class="n">energies</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2"> meV&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
          
    <span class="k">if</span> <span class="n">plot_bonds</span><span class="p">:</span>
         <span class="n">data</span> <span class="o">+=</span> <span class="n">get_plot_bonds</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_polyhedra</span> <span class="ow">or</span> <span class="n">plot_bonds</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">color</span><span class="o">==</span><span class="s1">&#39;energy&#39;</span><span class="p">:</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter3d</span><span class="p">(</span>
                        <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;markers&#39;</span><span class="p">,</span>
                        <span class="n">x</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">z</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span>
                        <span class="n">hovertemplate</span><span class="o">=</span><span class="s1">&#39;&lt;b&gt;%</span><span class="si">{text}</span><span class="s1">&lt;/b&gt;&lt;extra&gt;&lt;/extra&gt;&#39;</span><span class="p">,</span>
                        <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                            <span class="n">size</span><span class="o">=</span><span class="n">atom_size</span><span class="p">,</span>
                            <span class="n">sizemode</span><span class="o">=</span><span class="s1">&#39;diameter&#39;</span><span class="p">,</span>
                            <span class="n">colorscale</span><span class="o">=</span><span class="s1">&#39;Rainbow&#39;</span><span class="p">,</span> <span class="c1">#px.colors.qualitative.Light24,</span>
                            <span class="n">colorbar</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">thickness</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;h&#39;</span><span class="p">))))</span>
                            <span class="c1">#hover_name = colors)))  # [&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;])))        </span>
    
    <span class="k">elif</span> <span class="s1">&#39;bonds&#39;</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter3d</span><span class="p">(</span>
                        <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;markers&#39;</span><span class="p">,</span>
                        <span class="n">x</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">z</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span>
                        <span class="n">hovertemplate</span><span class="o">=</span><span class="s1">&#39;&lt;b&gt;%</span><span class="si">{text}</span><span class="s1">&lt;/b&gt;&lt;extra&gt;&lt;/extra&gt;&#39;</span><span class="p">,</span>
                        <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                            <span class="n">size</span><span class="o">=</span><span class="n">atom_size</span><span class="p">,</span>
                            <span class="n">sizemode</span><span class="o">=</span><span class="s1">&#39;diameter&#39;</span><span class="p">,</span>
                            <span class="n">colorscale</span><span class="o">=</span> <span class="n">px</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">qualitative</span><span class="o">.</span><span class="n">Light24</span><span class="p">)))</span>
                            <span class="c1">#hover_name = colors)))  # [&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;])))         </span>
            
    <span class="k">else</span><span class="p">:</span>
         <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter3d</span><span class="p">(</span>
                        <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;markers&#39;</span><span class="p">,</span>
                        <span class="n">x</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">z</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span>
                        <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                            <span class="n">size</span><span class="o">=</span><span class="n">atom_size</span><span class="p">,</span>
                            <span class="n">sizemode</span><span class="o">=</span><span class="s1">&#39;diameter&#39;</span><span class="p">,</span>
                            <span class="n">colorbar</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">thickness</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span>
                            <span class="n">colorscale</span><span class="o">=</span> <span class="n">px</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">qualitative</span><span class="o">.</span><span class="n">Light24</span><span class="p">)))</span>
                            <span class="c1">#hover_name = colors)))  # [&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;])))         </span>
    <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">700</span><span class="p">,</span> <span class="n">showlegend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">template</span><span class="o">=</span><span class="n">template</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span><span class="n">scene_aspectmode</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span>
                      <span class="n">scene_aspectratio</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">camera</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;up&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
              <span class="s1">&#39;center&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
              <span class="s1">&#39;eye&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}}</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">update_coloraxes</span><span class="p">(</span><span class="n">showscale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span><span class="n">scene_camera</span><span class="o">=</span><span class="n">camera</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;Al-GB $&quot;</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">update_scenes</span><span class="p">(</span><span class="n">camera_projection_type</span><span class="o">=</span><span class="s2">&quot;orthographic&quot;</span> <span class="p">)</span> 
    <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">fig</span></div>




<div class="viewcode-block" id="find_polyhedra"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.find_polyhedra.html#pyTEMlib.graph_tools.find_polyhedra">[docs]</a><span class="k">def</span> <span class="nf">find_polyhedra</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cheat</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">bond_radii</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; get polyhedra information from an ase.Atoms object</span>

<span class="sd">    This is following the method of Banadaki and Patala</span>
<span class="sd">    http://dx.doi.org/10.1038/s41524-017-0016-0</span>

<span class="sd">    We are using the bond radius according to Kirkland, which is tabulated in</span>
<span class="sd">        - pyTEMlib.crystal_tools.electronFF[atoms.symbols[vert]][&#39;bond_length&#39;][1]</span>

<span class="sd">    Parameter</span>
<span class="sd">    ---------</span>
<span class="sd">    atoms: ase.Atoms object</span>
<span class="sd">        the structural information</span>
<span class="sd">    cheat: float</span>
<span class="sd">        does not exist</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    polyhedra: dict</span>
<span class="sd">        dictionary with all information of polyhedra</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">ase</span><span class="o">.</span><span class="n">Atoms</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;This function needs an ase.Atoms object&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mf">0.01</span><span class="p">:</span>
        <span class="n">tetrahedra</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">Delaunay</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tetrahedra</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">Delaunay</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>

    <span class="n">voronoi_vertices</span><span class="p">,</span> <span class="n">voronoi_tetrahedrons</span><span class="p">,</span> <span class="n">r_vv</span><span class="p">,</span> <span class="n">r_a</span> <span class="o">=</span> <span class="n">get_voronoi</span><span class="p">(</span><span class="n">tetrahedra</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">optimize</span><span class="p">,</span> <span class="n">bond_radii</span><span class="o">=</span><span class="n">bond_radii</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mf">0.01</span><span class="p">:</span>
        <span class="n">r_vv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r_vv</span><span class="p">)</span><span class="o">*</span><span class="mf">3.</span>
    <span class="n">overlapping_pairs</span> <span class="o">=</span> <span class="n">find_overlapping_spheres</span><span class="p">(</span><span class="n">voronoi_vertices</span><span class="p">,</span> <span class="n">r_vv</span><span class="p">,</span> <span class="n">r_a</span><span class="p">,</span> <span class="n">cheat</span><span class="o">=</span><span class="n">cheat</span><span class="p">)</span>

    <span class="n">clusters</span><span class="p">,</span> <span class="n">visited_all</span> <span class="o">=</span> <span class="n">find_interstitial_clusters</span><span class="p">(</span><span class="n">overlapping_pairs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mf">0.01</span><span class="p">:</span>
        <span class="n">rings</span> <span class="o">=</span> <span class="n">get_polygons</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">voronoi_tetrahedrons</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rings</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">polyhedra</span> <span class="o">=</span> <span class="n">make_polyhedrons</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">voronoi_vertices</span><span class="p">,</span> <span class="n">voronoi_tetrahedrons</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">visited_all</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">polyhedra</span></div>


<div class="viewcode-block" id="polygon_sort"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.polygon_sort.html#pyTEMlib.graph_tools.polygon_sort">[docs]</a><span class="k">def</span> <span class="nf">polygon_sort</span><span class="p">(</span><span class="n">corners</span><span class="p">):</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">corners</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">corners</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">corners</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">%</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">corners</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">angles</span><span class="p">)]</span></div>

<div class="viewcode-block" id="get_polygons"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.get_polygons.html#pyTEMlib.graph_tools.get_polygons">[docs]</a><span class="k">def</span> <span class="nf">get_polygons</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">voronoi_tetrahedrons</span><span class="p">):</span>
    <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cyclicity</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">corners</span> <span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">)):</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">cc</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">voronoi_tetrahedrons</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
        
        <span class="n">sorted_corners</span> <span class="o">=</span> <span class="n">polygon_sort</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cc</span><span class="p">)),</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">cyclicity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_corners</span><span class="p">))</span>
        <span class="n">corners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sorted_corners</span><span class="p">)</span>
        <span class="n">centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sorted_corners</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patches</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sorted_corners</span><span class="p">)[:,:</span><span class="mi">2</span><span class="p">],</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">))</span>

    <span class="n">rings</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;atoms&#39;</span><span class="p">:</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span>
           <span class="s1">&#39;cyclicity&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cyclicity</span><span class="p">),</span>
           <span class="s1">&#39;centers&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">),</span>
           <span class="s1">&#39;corners&#39;</span><span class="p">:</span> <span class="n">corners</span><span class="p">,</span>
           <span class="s1">&#39;polygons&#39;</span><span class="p">:</span> <span class="n">polygons</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">rings</span></div>


<div class="viewcode-block" id="sort_polyhedra_by_vertices"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.sort_polyhedra_by_vertices.html#pyTEMlib.graph_tools.sort_polyhedra_by_vertices">[docs]</a><span class="k">def</span> <span class="nf">sort_polyhedra_by_vertices</span><span class="p">(</span><span class="n">polyhedra</span><span class="p">,</span> <span class="n">visible</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">z_lim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">polyhedron</span> <span class="ow">in</span> <span class="n">polyhedra</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="s1">&#39;length&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">polyhedron</span><span class="p">:</span>
            <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;vertices&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">visible</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;vertices&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">z_lim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">z_lim</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">polyhedron</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">],</span> <span class="n">center</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">indices</span></div>

<span class="c1"># color_scheme = [&#39;lightyellow&#39;, &#39;silver&#39;, &#39;rosybrown&#39;, &#39;lightsteelblue&#39;, &#39;orange&#39;, &#39;cyan&#39;, &#39;blue&#39;, &#39;magenta&#39;,</span>
<span class="c1">#                &#39;firebrick&#39;, &#39;forestgreen&#39;]</span>



<span class="c1">##########################</span>
<span class="c1"># New Graph Stuff</span>
<span class="c1">##########################</span>
<div class="viewcode-block" id="breadth_first_search"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.breadth_first_search.html#pyTEMlib.graph_tools.breadth_first_search">[docs]</a><span class="k">def</span> <span class="nf">breadth_first_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">projected_crystal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; breadth first search of atoms viewed as a graph</span>

<span class="sd">    the projection dictionary has to contain the following items</span>
<span class="sd">    &#39;number_of_nearest_neighbours&#39;, &#39;rotated_cell&#39;, &#39;near_base&#39;, &#39;allowed_variation&#39;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph: numpy array (Nx2)</span>
<span class="sd">        the atom positions</span>
<span class="sd">    initial: int</span>
<span class="sd">        index of starting atom</span>
<span class="sd">    projection_tags: dict</span>
<span class="sd">        dictionary with information on projected unit cell (with &#39;rotated_cell&#39; item)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    graph[visited]: numpy array (M,2) with M&lt;N</span>
<span class="sd">        positions of atoms hopped in unit cell lattice</span>
<span class="sd">    ideal: numpy array (M,2)</span>
<span class="sd">        ideal atom positions</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">projection_tags</span> <span class="o">=</span> <span class="n">projected_crystal</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;projection&#39;</span><span class="p">]</span>

    <span class="c1"># get lattice vectors to hopp along through graph</span>
    <span class="n">projected_unit_cell</span> <span class="o">=</span> <span class="n">projected_crystal</span><span class="o">.</span><span class="n">cell</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">a_lattice_vector</span> <span class="o">=</span> <span class="n">projected_unit_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b_lattice_vector</span> <span class="o">=</span> <span class="n">projected_unit_cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">main</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a_lattice_vector</span><span class="p">,</span> <span class="o">-</span><span class="n">a_lattice_vector</span><span class="p">,</span> <span class="n">b_lattice_vector</span><span class="p">,</span> <span class="o">-</span><span class="n">b_lattice_vector</span><span class="p">])</span>  <span class="c1"># vectors of unit cell</span>
    <span class="n">near</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">main</span><span class="p">,</span> <span class="n">projection_tags</span><span class="p">[</span><span class="s1">&#39;near_base&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># all nearest atoms</span>
    <span class="c1"># get k next nearest neighbours for each node</span>
    <span class="n">neighbour_tree</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">neighbour_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span>  <span class="c1"># let&#39;s get all neighbours</span>
                                              <span class="n">k</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>  <span class="c1"># projection_tags[&#39;number_of_nearest_neighbours&#39;]*2 + 1)</span>
    <span class="c1"># print(projection_tags[&#39;number_of_nearest_neighbours&#39;] * 2 + 1)</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the atoms we visited</span>
    <span class="n">ideal</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># atoms at ideal lattice</span>
    <span class="n">sub_lattice</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># atoms in base and disregarded</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial</span><span class="p">]</span>
    <span class="n">ideal_queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">graph</span><span class="p">[</span><span class="n">initial</span><span class="p">]]</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ideal_node</span> <span class="o">=</span> <span class="n">ideal_queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">ideal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ideal_node</span><span class="p">)</span>
            <span class="c1"># print(node,ideal_node)</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">neighbour</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">distance_to_ideal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">near</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">-</span> <span class="n">graph</span><span class="p">[</span><span class="n">neighbour</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distance_to_ideal</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">projection_tags</span><span class="p">[</span><span class="s1">&#39;allowed_variation&#39;</span><span class="p">]:</span>
                        <span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distance_to_ideal</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">direction</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># counting starts at 0</span>
                            <span class="n">sub_lattice</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">distances</span><span class="p">[</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">projection_tags</span><span class="p">[</span><span class="s1">&#39;distance_unit_cell&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.05</span><span class="p">:</span>
                            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span>
                            <span class="n">ideal_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ideal_node</span> <span class="o">+</span> <span class="n">near</span><span class="p">[</span><span class="n">direction</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">graph</span><span class="p">[</span><span class="n">visited</span><span class="p">],</span> <span class="n">ideal</span></div>

<span class="c1">####################</span>
<span class="c1"># Distortion Matrix</span>
<span class="c1">####################</span>
<div class="viewcode-block" id="get_distortion_matrix"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.get_distortion_matrix.html#pyTEMlib.graph_tools.get_distortion_matrix">[docs]</a><span class="k">def</span> <span class="nf">get_distortion_matrix</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">ideal_lattice</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;    Calculates distortion matrix</span>

<span class="sd">    Calculates the distortion matrix by comparing ideal and distorted Voronoi tiles</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">vor</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">Voronoi</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

    <span class="c1"># determine a middle Voronoi tile</span>
    <span class="n">ideal_vor</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">Voronoi</span><span class="p">(</span><span class="n">ideal_lattice</span><span class="p">)</span>
    <span class="n">near_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">ideal_lattice</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ideal_lattice</span> <span class="o">-</span> <span class="n">near_center</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="c1"># the ideal vertices fo such an Voronoi tile (are there crystals with more than one voronoi?)</span>
    <span class="n">ideal_vertices</span> <span class="o">=</span> <span class="n">ideal_vor</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">ideal_vor</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="n">ideal_vor</span><span class="o">.</span><span class="n">point_region</span><span class="p">[</span><span class="n">index</span><span class="p">]]]</span>
    <span class="n">ideal_vertices</span> <span class="o">=</span> <span class="n">get_significant_vertices</span><span class="p">(</span><span class="n">ideal_vertices</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">ideal_vertices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="n">distortion_matrix</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vor</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">done</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">vor</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># progress output :</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">%-50s</span><span class="s2">] </span><span class="si">%d%%</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;=&#39;</span> <span class="o">*</span> <span class="n">done</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">done</span><span class="p">))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="c1"># determine vertices of Voronoi polygons of an atom with number index</span>
        <span class="n">poly_point</span> <span class="o">=</span> <span class="n">vor</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">poly_vertices</span> <span class="o">=</span> <span class="n">get_significant_vertices</span><span class="p">(</span><span class="n">vor</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vor</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="n">vor</span><span class="o">.</span><span class="n">point_region</span><span class="p">[</span><span class="n">index</span><span class="p">]]]</span> <span class="o">-</span> <span class="n">poly_point</span><span class="p">)</span>

        <span class="c1"># where ATOM has to be moved (not pixel)</span>
        <span class="n">ideal_point</span> <span class="o">=</span> <span class="n">ideal_lattice</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="c1"># transform voronoi to ideal one and keep transformation matrix A</span>
        <span class="n">uncorrected</span><span class="p">,</span> <span class="n">corrected</span><span class="p">,</span> <span class="n">aa</span> <span class="o">=</span> <span class="n">transform_voronoi</span><span class="p">(</span><span class="n">poly_vertices</span><span class="p">,</span> <span class="n">ideal_vertices</span><span class="p">)</span>

        <span class="c1"># pixel positions</span>
        <span class="n">corrected</span> <span class="o">=</span> <span class="n">corrected</span> <span class="o">+</span> <span class="n">ideal_point</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">poly_point</span><span class="p">)</span> <span class="o">-</span> <span class="n">poly_point</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">corrected</span><span class="p">)):</span>
            <span class="c1"># original image pixels</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">uncorrected</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">poly_point</span><span class="p">)</span>
            <span class="c1"># collect the two origin and target coordinates and store</span>
            <span class="n">distortion_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">corrected</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">corrected</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">distortion_matrix</span><span class="p">)</span></div>


<div class="viewcode-block" id="undistort"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.undistort.html#pyTEMlib.graph_tools.undistort">[docs]</a><span class="k">def</span> <span class="nf">undistort</span><span class="p">(</span><span class="n">distortion_matrix</span><span class="p">,</span> <span class="n">image_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Undistort image according to distortion matrix</span>
<span class="sd">    </span>
<span class="sd">    Uses the griddata interpolation of scipy to apply distortion matrix to image.</span>
<span class="sd">    The distortion matrix contains in origin and target pixel coordinates</span>
<span class="sd">    target is where the pixel has to be moved (floats)</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    distortion_matrix: numpy array (Nx2)</span>
<span class="sd">        distortion matrix (format N x 2)</span>
<span class="sd">    image_data: numpy array or sidpy.Dataset</span>
<span class="sd">        image </span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    interpolated: numpy array</span>
<span class="sd">        undistorted image</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">intensity_values</span> <span class="o">=</span> <span class="n">image_data</span><span class="p">[(</span><span class="n">distortion_matrix</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">distortion_matrix</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))]</span>

    <span class="n">corrected</span> <span class="o">=</span> <span class="n">distortion_matrix</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

    <span class="n">size_x</span><span class="p">,</span> <span class="n">size_y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">image_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))</span>  <span class="c1"># nearest power of 2</span>
    <span class="n">size_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size_x</span><span class="p">)</span>
    <span class="n">size_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size_y</span><span class="p">)</span>
    <span class="n">grid_x</span><span class="p">,</span> <span class="n">grid_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">size_x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">size_x</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">size_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">size_y</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;interpolate&#39;</span><span class="p">)</span>

    <span class="n">interpolated</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">griddata</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corrected</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">intensity_values</span><span class="p">),</span> <span class="p">(</span><span class="n">grid_x</span><span class="p">,</span> <span class="n">grid_y</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">interpolated</span></div>


<span class="k">def</span> <span class="nf">transform_voronoi</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">ideal_voronoi</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; find transformation matrix A between a distorted polygon and a perfect reference one</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    uncorrected: list of points: </span>
<span class="sd">        all points on a grid within original polygon</span>
<span class="sd">    corrected: list of points: </span>
<span class="sd">        coordinates of these points where pixel have to move to</span>
<span class="sd">    aa: 2x2 matrix A:  </span>
<span class="sd">        transformation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Find Transformation Matrix, note polygons have to be ordered first.</span>
    <span class="n">sort_vert</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">ideal_voronoi</span><span class="p">:</span>
        <span class="n">sort_vert</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vertices</span> <span class="o">-</span> <span class="n">vert</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">)[</span><span class="n">sort_vert</span><span class="p">]</span>

    <span class="c1"># Solve the least squares problem X * A = Y</span>
    <span class="c1"># to find our transformation matrix aa = A</span>
    <span class="n">aa</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">ideal_voronoi</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># expand polygon to include more points in distortion matrix</span>
    <span class="n">vertices2</span> <span class="o">=</span> <span class="n">vertices</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>  <span class="c1"># +np.sign(vertices)</span>

    <span class="n">ext_v</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vertices2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">polygon_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ext_v</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">ext_v</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ext_v</span>
    <span class="n">polygon_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">polygon_grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">polygon_array</span> <span class="o">=</span> <span class="n">polygon_grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">polygon_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">points_in_poly</span><span class="p">(</span><span class="n">polygon_array</span><span class="p">,</span> <span class="n">vertices2</span><span class="p">)</span>
    <span class="n">uncorrected</span> <span class="o">=</span> <span class="n">polygon_array</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>

    <span class="n">corrected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">uncorrected</span><span class="p">,</span> <span class="n">aa</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">uncorrected</span><span class="p">,</span> <span class="n">corrected</span><span class="p">,</span> <span class="n">aa</span>


<div class="viewcode-block" id="get_maximum_view"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.get_maximum_view.html#pyTEMlib.graph_tools.get_maximum_view">[docs]</a><span class="k">def</span> <span class="nf">get_maximum_view</span><span class="p">(</span><span class="n">distortion_matrix</span><span class="p">):</span>
    <span class="n">distortion_matrix_extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">distortion_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">distortion_matrix_extent</span><span class="p">[</span><span class="n">distortion_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1000.</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">area</span> <span class="o">=</span> <span class="n">distortion_matrix_extent</span>
    <span class="n">view_square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">distortion_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">distortion_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">area</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">view_square</span> <span class="o">=</span> <span class="n">view_square</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">distortion_matrix_extent</span><span class="p">[</span><span class="n">view_square</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">view_square</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">view_square</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">view_square</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>

    <span class="n">change</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distortion_matrix_extent</span><span class="p">[:</span><span class="n">view_square</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">view_square</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">view_square</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))),</span>
              <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distortion_matrix_extent</span><span class="p">[</span><span class="n">view_square</span><span class="p">[</span><span class="mi">1</span><span class="p">]:,</span> <span class="n">view_square</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">view_square</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))),</span>
              <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distortion_matrix_extent</span><span class="p">[</span><span class="n">view_square</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">view_square</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:</span><span class="n">view_square</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))),</span>
              <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distortion_matrix_extent</span><span class="p">[</span><span class="n">view_square</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">view_square</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">view_square</span><span class="p">[</span><span class="mi">3</span><span class="p">]:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))]</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">view_square</span><span class="p">)</span> <span class="o">+</span> <span class="n">change</span></div>


<div class="viewcode-block" id="get_significant_vertices"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.get_significant_vertices.html#pyTEMlib.graph_tools.get_significant_vertices">[docs]</a><span class="k">def</span> <span class="nf">get_significant_vertices</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate average for  all points that are closer than distance apart, otherwise leave the points alone</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vertices: numpy array (n,2)</span>
<span class="sd">            list of points</span>
<span class="sd">        distance: float</span>
<span class="sd">            (in same scale as points )</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ideal_vertices: list of floats</span>
<span class="sd">            list of points that are all a minimum of 3 apart.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tt</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>
    <span class="n">near</span> <span class="o">=</span> <span class="n">tt</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>
    <span class="n">ideal_vertices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">near</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ideal_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">indices</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ideal_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">ideal_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ideal_vertices</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">ideal_vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ideal_vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">ang_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>

    <span class="n">ideal_vertices</span> <span class="o">=</span> <span class="n">ideal_vertices</span><span class="p">[</span><span class="n">ang_sort</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ideal_vertices</span></div>


<div class="viewcode-block" id="transform_voronoi"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.transform_voronoi.html#pyTEMlib.graph_tools.transform_voronoi">[docs]</a><span class="k">def</span> <span class="nf">transform_voronoi</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">ideal_voronoi</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    find transformation matrix A between a polygon and a perfect one</span>
<span class="sd">    </span>
<span class="sd">    returns:</span>
<span class="sd">    list of points: all points on a grid within original polygon</span>
<span class="sd">    list of points: coordinates of these points where pixel have to move to</span>
<span class="sd">    2x2 matrix aa:  transformation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find Transformation Matrix, note polygons have to be ordered first.</span>
    <span class="n">sort_vert</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">ideal_voronoi</span><span class="p">:</span>
        <span class="n">sort_vert</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vertices</span> <span class="o">-</span> <span class="n">vert</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">)[</span><span class="n">sort_vert</span><span class="p">]</span>

    <span class="c1"># Solve the least squares problem X * A = Y</span>
    <span class="c1"># to find our transformation matrix A</span>
    <span class="n">aa</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">ideal_voronoi</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># expand polygon to include more points in distortion matrix </span>
    <span class="n">vertices2</span> <span class="o">=</span> <span class="n">vertices</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>  <span class="c1"># +np.sign(vertices)</span>

    <span class="n">ext_v</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vertices2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">polygon_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ext_v</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">ext_v</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ext_v</span>
    <span class="n">polygon_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">polygon_grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">polygon_array</span> <span class="o">=</span> <span class="n">polygon_grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">polygon_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">points_in_poly</span><span class="p">(</span><span class="n">polygon_array</span><span class="p">,</span> <span class="n">vertices2</span><span class="p">)</span>
    <span class="n">uncorrected</span> <span class="o">=</span> <span class="n">polygon_array</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>

    <span class="n">corrected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">uncorrected</span><span class="p">,</span> <span class="n">aa</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">uncorrected</span><span class="p">,</span> <span class="n">corrected</span><span class="p">,</span> <span class="n">aa</span></div>



<div class="viewcode-block" id="undistort_sitk"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.undistort_sitk.html#pyTEMlib.graph_tools.undistort_sitk">[docs]</a><span class="k">def</span> <span class="nf">undistort_sitk</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span> <span class="n">distortion_matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;    use simple ITK to undistort image</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image_data: numpy array with size NxM </span>
<span class="sd">    distortion_matrix: sidpy.Dataset or numpy array with size 2 x P x Q</span>
<span class="sd">    with P, Q &gt;= M, N</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image: numpy array MXN</span>
<span class="sd">      </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">resampler</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">ResampleImageFilter</span><span class="p">()</span>
    <span class="n">resampler</span><span class="o">.</span><span class="n">SetReferenceImage</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">image_data</span><span class="p">))</span>
    <span class="n">resampler</span><span class="o">.</span><span class="n">SetInterpolator</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">sitkBSpline</span><span class="p">)</span>
    <span class="n">resampler</span><span class="o">.</span><span class="n">SetDefaultPixelValue</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">distortion_matrix2</span> <span class="o">=</span> <span class="n">distortion_matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="n">image_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:</span><span class="n">image_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="n">displ2</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">Compose</span><span class="p">(</span>
        <span class="p">[</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="o">-</span><span class="n">distortion_matrix2</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="o">-</span><span class="n">distortion_matrix2</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
    <span class="n">out_tx</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">DisplacementFieldTransform</span><span class="p">(</span><span class="n">displ2</span><span class="p">)</span>
    <span class="n">resampler</span><span class="o">.</span><span class="n">SetTransform</span><span class="p">(</span><span class="n">out_tx</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">resampler</span><span class="o">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">image_data</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="undistort_stack_sitk"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.undistort_stack_sitk.html#pyTEMlib.graph_tools.undistort_stack_sitk">[docs]</a><span class="k">def</span> <span class="nf">undistort_stack_sitk</span><span class="p">(</span><span class="n">distortion_matrix</span><span class="p">,</span> <span class="n">image_stack</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    use simple ITK to undistort stack of image</span>
<span class="sd">    input:</span>
<span class="sd">    image: numpy array with size NxM </span>
<span class="sd">    distortion_matrix: h5 Dataset or numpy array with size 2 x P x Q</span>
<span class="sd">    with P, Q &gt;= M, N</span>
<span class="sd">    output:</span>
<span class="sd">    image M, N</span>
<span class="sd">      </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">resampler</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">ResampleImageFilter</span><span class="p">()</span>
    <span class="n">resampler</span><span class="o">.</span><span class="n">SetReferenceImage</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">image_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">resampler</span><span class="o">.</span><span class="n">SetInterpolator</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">sitkBSpline</span><span class="p">)</span>
    <span class="n">resampler</span><span class="o">.</span><span class="n">SetDefaultPixelValue</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">displ2</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">Compose</span><span class="p">(</span>
        <span class="p">[</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="o">-</span><span class="n">distortion_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="o">-</span><span class="n">distortion_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
    <span class="n">out_tx</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">DisplacementFieldTransform</span><span class="p">(</span><span class="n">displ2</span><span class="p">)</span>
    <span class="n">resampler</span><span class="o">.</span><span class="n">SetTransform</span><span class="p">(</span><span class="n">out_tx</span><span class="p">)</span>

    <span class="n">interpolated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">image_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">nimages</span> <span class="o">=</span> <span class="n">image_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">QT_available</span><span class="p">:</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="n">pyTEMlib</span><span class="o">.</span><span class="n">sidpy_tools</span><span class="o">.</span><span class="n">ProgressDialog</span><span class="p">(</span><span class="s2">&quot;Correct Scan Distortions&quot;</span><span class="p">,</span> <span class="n">nimages</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nimages</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">QT_available</span><span class="p">:</span>
            <span class="n">progress</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">resampler</span><span class="o">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">image_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">interpolated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="n">progress</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">QT_available</span><span class="p">:</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">interpolated</span></div>


<div class="viewcode-block" id="undistort_stack"><a class="viewcode-back" href="../../_autosummary/pyTEMlib.graph_tools.undistort_stack.html#pyTEMlib.graph_tools.undistort_stack">[docs]</a><span class="k">def</span> <span class="nf">undistort_stack</span><span class="p">(</span><span class="n">distortion_matrix</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Undistort stack with distortion matrix</span>
<span class="sd">    </span>
<span class="sd">    Use the griddata interpolation of scipy to apply distortion matrix to image</span>
<span class="sd">    The distortion matrix contains in each pixel where the pixel has to be moved (floats)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    distortion_matrix: numpy array</span>
<span class="sd">        distortion matrix to undistort image (format image.shape[0], image.shape[2], 2)</span>
<span class="sd">    data: numpy array or sidpy.Dataset</span>
<span class="sd">        image</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">corrected</span> <span class="o">=</span> <span class="n">distortion_matrix</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">intensity_values</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">distortion_matrix</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">distortion_matrix</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

    <span class="n">size_x</span><span class="p">,</span> <span class="n">size_y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>  <span class="c1"># nearest power of 2</span>
    <span class="n">size_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size_x</span><span class="p">)</span>
    <span class="n">size_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size_y</span><span class="p">)</span>

    <span class="n">grid_x</span><span class="p">,</span> <span class="n">grid_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">size_x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">size_x</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">size_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">size_y</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;interpolate&#39;</span><span class="p">)</span>

    <span class="n">interpolated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size_x</span><span class="p">,</span> <span class="n">size_y</span><span class="p">])</span>
    <span class="n">nimages</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">QT_available</span><span class="p">:</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="n">ft</span><span class="o">.</span><span class="n">ProgressDialog</span><span class="p">(</span><span class="s2">&quot;Correct Scan Distortions&quot;</span><span class="p">,</span> <span class="n">nimages</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nimages</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">QT_available</span><span class="p">:</span>
            <span class="n">progress</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">done</span> <span class="o">&lt;</span> <span class="nb">int</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nimages</span> <span class="o">*</span> <span class="mi">50</span><span class="p">):</span>
            <span class="n">done</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nimages</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># progress output :</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">%-50s</span><span class="s2">] </span><span class="si">%d%%</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;=&#39;</span> <span class="o">*</span> <span class="n">done</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">done</span><span class="p">))</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="n">interpolated</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">corrected</span><span class="p">,</span> <span class="n">intensity_values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="p">(</span><span class="n">grid_x</span><span class="p">,</span> <span class="n">grid_y</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">QT_available</span><span class="p">:</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;:-)&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;You have successfully completed undistortion of image stack&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">interpolated</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Gerd Duscher, and contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>